---
title: "Simple kinetic model simulations"
output:
  html_document:
    code_folding: "hide"
    toc: true
    toc_float: true
    toc_collapsed: true
    toc_depth: 3
    number_sections: true
    theme: lumen
---

<style type="text/css">

body{ /* Normal  */
      font-size: 16px;
  }
td {  /* Table  */
  font-size: 16px;
}
h1.title {
  font-size: 28px;
}
h1 { /* Header 1 */
  font-size: 24px;
}
h2 { /* Header 2 */
    font-size: 22px;
}
h3 { /* Header 3 */
  font-size: 20px;
}
code.r{ /* Code block */
    font-size: 12px;
}
pre { /* Code block - determines code spacing between lines */
    font-size: 14px;
}
</style>


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, error = FALSE, message = FALSE)

if (!require('tidyverse')) install.packages('tidyverse'); library('tidyverse') # for everything
if (!require('progress')) install.packages('progress'); library('progress') # for progress bar

set.seed(321)
```

# Overview

We first set up a free energy diagram for the simple reaction E + S = ES -> E + P. Then I extract rate and equilibrium constants using the free energies, and make the assumption for rate constants that the Arrhenius constant is *k*~b~ * T / *h*.

Next, we introduce 1000 random "mutations" which sample from -2 to 2 kcal mol^-1^ and modulate the energy of each ground and/or transition state by that amount. These are all save in a spreadsheet (see Supplementary data 1).

Finally, we test all combinations of the 1000 mutations and calculate the predicted and observed rate constants.

# Setup

First we need to setup the free energy profile based on the simple reaction E + S = ES -> E + P

The free energies will be set up in the energies vector

```{r}
energies <- list(e = 0,
                 e_s_dagger = 10,
                 es = -5,
                 es_dagger = 11
)
```

Then we define the global constants

```{r}
kb = 3.297623483e-27 # kcal/K
h = 1.58e-37 # kcal s
temp = 273+25 # K in room temp
r = 1.9872036e-3 # kcal K-1 mol-1
A = (kb*temp)/h # Collision constant as defined broadly by transition state theory
```

We note that a more accurate approximation of the *A* constant would utilize collision theory, due to the nature of E + S representing a bimolecular collision of E + S. This means that the rate constant can theoretically approach `r A` which exceeds rate-limiting diffusion. Nevertheless, we retain this approximation for simplicity.

Then we can define the equations for rate constants using the energy terms:

```{r}
define_constants <- function(energies) {
  kon = A*exp(-1*(energies$e_s_dagger-energies$e) / (r*temp)) # M s-1
  koff = A*exp(-1*(energies$e_s_dagger-energies$es) / (r*temp)) # s-1
  kchem = A*exp(-1*(energies$es_dagger-energies$es) / (r*temp)) # s-1
  
  kd = koff/kon
  kcat = kchem
  km = (koff+kchem)/kon
  catef = kcat/km
  
  return(list(kon = kon, 
              koff = koff, 
              kchem = kchem, 
              kd = kd, 
              kcat = kcat, 
              km = km,
              catef = catef))
}
```

And check the values for each constants (see **Table 1** in the main text)

```{r}
cur_const <- define_constants(energies)
cur_const
```

These seem like decent starting conditions for the experiment with *k*~on~ ~ 2.8e5, *k*~off~ ~ 60, *k*~cat~ ~ 11, *K*~M~ ~ 255 µM, *K*~D~ ~ 215 µM, and a *k*~cat~ / *K*~M~ of 4.5e4

# Mutational simulations

First we prepare a table to store the free energies and rate constants of the mutants:

```{r}
dt <- tibble(e = numeric(),
             e_s_dagger = numeric(),
             es = numeric(),
             es_dagger = numeric(),
             kon = numeric(),
             koff = numeric(),
             kchem = numeric(),
             kd = numeric(),
             kcat = numeric(),
             km = numeric(),
             catef = numeric())

dt <- rbind(dt, c(unlist(energies), unlist(cur_const)))
names(dt) = c("e",
              "e_s_dagger",
              "es",
              "es_dagger",
              "kon",
              "koff",
              "kchem",
              "kd",
              "kcat",
              "km",
              "catef")
dt
```

## Mutational sampling

Then we can setup a simulation where each mutant free energy is the sum of the wt free energy and a randomly chosen energy ranging from -2 to 2 kcal mol^-1^

```{r}
mutation <- function(dt){
  # Assuming mutation can change all steps by a random amount
  new_energies <- list(e = energies$e + runif(1, -2, 2),
                   e_s_dagger = energies$e_s_dagger + runif(1, -2, 2),
                   es = energies$es + runif(1, -2, 2),
                   es_dagger = energies$es_dagger + runif(1, -2, 2))
  mut_const <- define_constants(new_energies)
  
  return(rbind(dt, c(unlist(new_energies), unlist(mut_const))))
}
```

And we simulate 1000 mutations and export the data into **Supplementary data 1**

```{r}
for(i in 1:1000){
  dt <- mutation(dt)
}

head(dt)
write_csv(dt, "Supplementary Data 1.csv")
```

# General statistics

We interrogate the spread of *K*~D~, *k*~cat~, *K*~M~, and *k*~cat~ / *K*~M~ for the 1000 single mutants (see **Fig. 1b** in the main text)

```{r}
dt_all_spread <- dt %>%
  mutate(kcat_norm = log10(kcat / kcat[1]),
         kd_norm = log10(kd / kd[1]),
         km_norm = log10(km / km[1]),
         catef_norm = log10(catef / catef[1])) %>%
  pivot_longer(c(kcat_norm, kd_norm, km_norm, catef_norm)) %>%
  select(name, value)

# Change density plot fill colors by groups
dt_all_spread_plot <- dt_all_spread %>%
  ggplot(aes(x = value, fill = name)) +
  geom_density() +
  scale_fill_manual(values = c("#745fe8","#ca3a7d","#ea692f","#f3b33e")) +
  geom_vline(xintercept = log10(1), col = "black", lty = 2) +
  xlim(c(-5, 5)) +
  labs(x = "log10 parameter value", y = "Density") +
  theme_classic()
  #theme(axis.line = element_line(size = 0.2, color = "black"), axis.ticks = element_line(size = 0.2, color = "black"), text = element_text(size = 9), axis.text = element_text(size = 8, color = "black"), legend.position = "none")

dt_all_spread_plot

#ggsave("density_plot_1.svg", plot = dt_all_spread_plot, width = 180/2, height = 247/4, dpi = 300, units = "mm")

```

# Simulation of mutational combinations

Next, we create 10^6^ double mutants by combining mutational effects from each single mutant found in **S1 data**. We compute the predicted kinetic parameters and observed parameters as follows:

For predicted kinetic parameters, we take the product of the wt kinetic parameter, the fold-change of mutation 1, and the fold-change of mutation 2. For the observed kinetic parameter, we first compute each microscopic rate constant of the double mutant by calculating the sum of free energy changes to each state in the reaction coordinate based on the single mutation effects. Then, we use the newly computed rate constants to obtained the *true* kinetic parameter of the double mutant.

We quantify epistasis as the ratio of the predicted vs observed kinetic parameter, and consider it significant if it exceeds 1.5-fold.

For each kinetic parameter, we also collect information on the fold change of the single mutation effect to determine whether the double mutant exhibits sign or magnitude epistasis.

```{r}
# Check for file, you can just upload if this is the case
if(file.exists('Supplementary Data 2.csv')){
  epi_dt <- read_csv("Supplementary Data 2.csv")
} else {
  # Generate all pairwise combinations of mutations
mut_combinations <- combn(2:(nrow(dt) - 1), 2, simplify = FALSE)

# Initialize a progress bar - ONLY WORKS IN CONSOLE, NOT IN RMD
pb <- progress_bar$new(
  format = "  Processing [:bar] :percent in :elapsed, ETA: :eta",
  total = length(mut_combinations),
  clear = FALSE,
  width = 60
)

# Process combinations with progress bar (console only)
epi_dt <- map_dfr(mut_combinations, function(pair) {
  pb$tick()  # Update progress bar at each iteration
  i <- pair[1]
  j <- pair[2]
  
  wt_catef <- dt$catef[1]
  mut1_fold_catef <- dt$catef[i] / wt_catef
  mut2_fold_catef <- dt$catef[j] / wt_catef
  
  pred_catef <- wt_catef * mut1_fold_catef * mut2_fold_catef
  
  wt_km <- dt$km[1]
  mut1_fold_km <- dt$km[i] / wt_km
  mut2_fold_km <- dt$km[j] / wt_km
  
  pred_km <- wt_km * mut1_fold_km * mut2_fold_km
  
  wt_kd <- dt$kd[1]
  mut1_fold_kd <- dt$kd[i] / wt_kd
  mut2_fold_kd <- dt$kd[j] / wt_kd
  
  pred_kd <- wt_kd * mut1_fold_kd * mut2_fold_kd
  
  wt_kcat <- dt$kcat[1]
  mut1_fold_kcat <- dt$kcat[i] / wt_kcat
  mut2_fold_kcat <- dt$kcat[j] / wt_kcat
  
  pred_kcat <- wt_kcat * mut1_fold_kcat * mut2_fold_kcat
  
  mut_e <- dt$e[1] + (dt$e[i] - dt$e[1] + dt$e[j] - dt$e[1])
  mut_e_s_dagger <- dt$e_s_dagger[1] + (dt$e_s_dagger[i] - dt$e_s_dagger[1] + dt$e_s_dagger[j] - dt$e_s_dagger[1])
  mut_es <- dt$es[1] + (dt$es[i] - dt$es[1] + dt$es[j] - dt$es[1])
  mut_es_dagger <- dt$es_dagger[1] + (dt$es_dagger[i] - dt$es_dagger[1] + dt$es_dagger[j] - dt$es_dagger[1])
  mut_e_p <- dt$e_p[1] + (dt$e_p[i] - dt$e_p[1] + dt$e_p[j] - dt$e_p[1])
  
  mut_energies <- list(e = mut_e, e_s_dagger = mut_e_s_dagger, es = mut_es, es_dagger = mut_es_dagger, e_p = mut_e_p)
  cur_mut_const <- define_constants(mut_energies)
  
  tibble(
    e = mut_energies$e,
    e_s_dagger = mut_energies$e_s_dagger,
    es = mut_energies$es,
    es_dagger = mut_energies$es_dagger,
    kon = cur_mut_const$kon,
    koff = cur_mut_const$koff,
    kchem = cur_mut_const$kchem,
    kd = cur_mut_const$kd,
    kcat = cur_mut_const$kcat,
    km = cur_mut_const$km,
    catef = cur_mut_const$catef,
    pred_catef = pred_catef,
    pred_km = pred_km,
    pred_kd = pred_kd,
    pred_kcat = pred_kcat,
    mut1_fold = mut1_fold_catef,
    mut2_fold = mut2_fold_catef,
    mut1_fold_km = mut1_fold_km,
    mut2_fold_km = mut2_fold_km,
    mut1_fold_kcat = mut1_fold_kcat,
    mut2_fold_kcat = mut2_fold_kcat,
    mut1_fold_kd = mut1_fold_kd,
    mut2_fold_kd = mut2_fold_kd,
    mut1_koff = dt$koff[i],
    mut2_koff = dt$koff[j],
    mut1_kchem = dt$kchem[i],
    mut2_kchem = dt$kchem[j],
    mut1 = i,
    mut2 = j
  )
})

head(epi_dt)

write_csv(epi_dt, "Supplementary Data 2.csv")
}
```

# Investigation of mutational combinations

## Significant epistasis in *k*~cat~ / *K*~M~ 

First I establish a function to calculate significant epistasis and classify it as magnitude, sign, and reciprocal sign

```{r}
sig_epi_classification <- function(sig_thresh, epi_dt) {
  this_df <- epi_dt %>%
  mutate(sign_change = log10(catef/dt$catef[1]),
         sign_mut1 = log10(mut1_fold),
         sign_mut2 = log10(mut2_fold),
         epi = log10(catef/pred_catef)) %>%
  mutate(sign = case_when( ((epi > log10(sig_thresh) | epi < log10(1/sig_thresh)) & sign_mut1 > 0 & sign_mut2 > 0 & sign_change < 0) ~ "reciprocal",
                           ((epi > log10(sig_thresh) | epi < log10(1/sig_thresh)) & sign_mut1 < 0 & sign_mut2 < 0 & sign_change > 0) ~ "reciprocal",
                           ((epi > log10(sig_thresh) | epi < log10(1/sig_thresh)) & sign_mut1 > 0 & sign_mut2 < 0 & (sign_change > sign_mut1 | sign_change < sign_mut2) ) ~ "sign",
                           ((epi > log10(sig_thresh) | epi < log10(1/sig_thresh)) & sign_mut1 < 0 & sign_mut2 > 0 & (sign_change < sign_mut1 | sign_change > sign_mut2) ) ~ "sign",
                           (epi > log10(sig_thresh) | epi < log10(1/sig_thresh)) ~ "magnitude",
                           TRUE ~ "no epistasis"))
  
  return(this_df)
}
```

Then, we check much significant epistasis is there in *k*~cat~ / *K*~M~ with a 1.5-fold threshold?

```{r}
epi_dt_2_sig <- sig_epi_classification(1.5, epi_dt)
epi_dt_2_sig %>% count(sign) %>% mutate(n / sum(n) * 100)
```

What about a 2-fold threshold?

```{r}
epi_dt_2_sig <- sig_epi_classification(2, epi_dt)
epi_dt_2_sig %>% count(sign) %>% mutate(n / sum(n) * 100)
```

A 5-fold threshold?

```{r}
epi_dt_2_sig <- sig_epi_classification(5, epi_dt)
epi_dt_2_sig %>% count(sign) %>% mutate(n / sum(n) * 100)
```

A 10-fold threshold?

```{r}
epi_dt_2_sig <- sig_epi_classification(10, epi_dt)
epi_dt_2_sig %>% count(sign) %>% mutate(n / sum(n) * 100)
```

Note that sign epistasis does not disappear even at high significance thresholds

## Significant epistasis in *k*~cat~

```{r}
epi_dt %>%
  mutate(sign_change = log10(kcat/dt$kcat[1]),
         epi = log10(kcat/pred_kcat)) %>%
  mutate(sign = case_when( (epi > log10(1.5) | epi < log10(1/1.5)) ~ "epistasis",
                           TRUE ~ "no epistasis")
         
  ) %>%
  count(sign) %>% mutate(n / sum(n) * 100)
```

## Significant epistasis in *K*~M~

```{r}
sig_epi_classification_km <- function(sig_thresh, epi_dt) {
  this_df <- epi_dt %>%
  mutate(sign_change = log10(km/dt$km[1]),
         sign_mut1 = log10(mut1_fold_km),
         sign_mut2 = log10(mut2_fold_km),
         epi = log10(km/pred_km)) %>%
  mutate(sign = case_when( ((epi > log10(sig_thresh) | epi < log10(1/sig_thresh)) & sign_mut1 > 0 & sign_mut2 > 0 & sign_change < 0) ~ "reciprocal",
                           ((epi > log10(sig_thresh) | epi < log10(1/sig_thresh)) & sign_mut1 < 0 & sign_mut2 < 0 & sign_change > 0) ~ "reciprocal",
                           ((epi > log10(sig_thresh) | epi < log10(1/sig_thresh)) & sign_mut1 > 0 & sign_mut2 < 0 & (sign_change > sign_mut1 | sign_change < sign_mut2) ) ~ "sign",
                           ((epi > log10(sig_thresh) | epi < log10(1/sig_thresh)) & sign_mut1 < 0 & sign_mut2 > 0 & (sign_change < sign_mut1 | sign_change > sign_mut2) ) ~ "sign",
                           (epi > log10(sig_thresh) | epi < log10(1/sig_thresh)) ~ "magnitude",
                           TRUE ~ "no epistasis"))
  
  return(this_df)
}
```

```{r}
epi_dt_2_sig <- sig_epi_classification_km(1.5, epi_dt)
epi_dt_2_sig %>% count(sign) %>% mutate(n / sum(n) * 100)
```

At a 2-fold threshold?

```{r}
epi_dt_2_sig <- sig_epi_classification_km(2, epi_dt)
epi_dt_2_sig %>% count(sign) %>% mutate(n / sum(n) * 100)
```

At a 5-fold threshold?

```{r}
epi_dt_2_sig <- sig_epi_classification_km(5, epi_dt)
epi_dt_2_sig %>% count(sign) %>% mutate(n / sum(n) * 100)
```

At a 10-fold threshold?

```{r}
epi_dt_2_sig <- sig_epi_classification_km(10, epi_dt)
epi_dt_2_sig %>% count(sign) %>% mutate(n / sum(n) * 100)
```

## Significant epistasis in *K*~D~

```{r}
epi_dt %>%
  mutate(sign_change = log10(kd/dt$kd[1]),
         epi = log10(kd/pred_kd)) %>%
  mutate(sign = case_when( (epi > log10(1.5) | epi < log10(1/1.5)) ~ "epistasis",
                           TRUE ~ "no epistasis")
         
  ) %>%
  count(sign) %>% mutate(n / sum(n) * 100)
```

## Correlation plots of predicted vs observed effects

What is the plot of *k*~cat~ / *K*~M~ of predicted vs observed employing a 1.5-fold threshold?

```{r}
epi_dt_2_sig <- sig_epi_classification(1.5, epi_dt)

epi_dt_2_sig_catef_plot <- epi_dt_2_sig %>%
  mutate(sign = factor(sign, levels = c("no epistasis", "magnitude", "sign", "reciprocal"))) %>%
  ggplot(aes(x = log10(pred_catef), y = log10(catef), color = sign)) +
  geom_point(alpha = 0.4, size = 0.5) +
  geom_abline(slope = 1, intercept = 0, linewidth = 0.3) +
  geom_hline(yintercept = log10(dt[1,]$catef), lty = 2, linewidth = 0.3) +
  geom_vline(xintercept = log10(dt[1,]$catef), lty = 2, linewidth = 0.3) +
  scale_color_manual(values = c("grey","#E69F00","#1f78b4","#d73027")) +
  labs(x = "Log10(Predicted kcat/Km)", "Log10(Observed kcat/Km)") +
  theme_classic() +
  theme(axis.line = element_line(size = 0.3, color = "black"), axis.ticks = element_line(size = 0.2, color = "black"), text = element_text(size = 9), axis.text = element_text(size = 8, color = "black"))

epi_dt_2_sig_catef_plot

##ggsave("catef_muts.tiff", plot = epi_dt_2_sig_catef_plot, width = 180/2, height = 247/4, dpi = 600, units = "mm")
```

What is the plot of *K*~M~ predicted vs observed?

```{r}
epi_dt_2_sig_km <- sig_epi_classification_km(1.5, epi_dt)

epi_dt_2_sig_km_plot <- epi_dt_2_sig_km %>%
  mutate(sign = factor(sign, levels = c("no epistasis", "magnitude", "sign", "reciprocal"))) %>%
  ggplot(aes(x = log10(pred_km), y = log10(km), color = sign)) +
  geom_point(alpha = 0.4, size = 0.5) +
  geom_abline(slope = 1, intercept = 0, linewidth = 0.3) +
  geom_hline(yintercept = log10(dt[1,]$km), lty = 2, linewidth = 0.3) +
  geom_vline(xintercept = log10(dt[1,]$km), lty = 2, linewidth = 0.3) +
  scale_color_manual(values = c("grey","#E69F00","#1f78b4","#d73027")) +
  labs(x = "Log10(Predicted Km)", "Log10(Observed Km)") +
  theme_classic() +
  theme(axis.line = element_line(size = 0.3, color = "black"), axis.ticks = element_line(size = 0.2, color = "black"), text = element_text(size = 9), axis.text = element_text(size = 8, color = "black"))

epi_dt_2_sig_km_plot

##ggsave("km_muts.tiff", plot = epi_dt_2_sig_km_plot, width = 180/2, height = 247/4, dpi = 600, units = "mm")
```

What is the plot of *k*~cat~ predicted vs observed?

```{r}
epi_dt_2_sig_kcat <- epi_dt %>%
  mutate(sign_change = log10(kcat/dt$kcat[1]),
         epi = log10(kcat/pred_kcat)) %>%
  mutate(sign = case_when( (epi > log10(1.5) | epi < log10(1/1.5)) ~ "epistasis",
                           TRUE ~ "no epistasis"))

# View(dt %>% mutate(across(everything(), ~ . - first(.))))

epi_dt_2_sig_kcat_plot <- epi_dt_2_sig_kcat %>%
  ggplot(aes(x = log10(pred_kcat), y = log10(kcat), color = sign)) +
  geom_point(alpha = 0.4) +
  geom_abline(slope = 1, intercept = 0, linewidth = 0.3) +
  geom_hline(yintercept = log10(dt[1,]$kcat), lty = 2, linewidth = 0.3) +
  geom_vline(xintercept = log10(dt[1,]$kcat), lty = 2, linewidth = 0.3) +
  scale_color_manual(values = c("grey")) +
  labs(x = "Log10(Predicted kcat)", "Log10(Observed kcat)") +
  theme_classic() +
  theme(axis.line = element_line(size = 0.3, color = "black"), axis.ticks = element_line(size = 0.2, color = "black"), text = element_text(size = 9), axis.text = element_text(size = 8, color = "black"))

epi_dt_2_sig_kcat_plot

#ggsave("kcat_muts.tiff", plot = epi_dt_2_sig_kcat_plot, width = 180/2, height = 247/4, dpi = 600, units = "mm")
```

What is the plot of *K*~D~ predicted vs observed?

```{r}
epi_dt_2_sig_kd <- epi_dt %>%
  mutate(sign_change = log10(kd/dt$kd[1]),
         epi = log10(kd/pred_kd)) %>%
  mutate(sign = case_when( (epi > log10(1.5) | epi < log10(1/1.5)) ~ "epistasis",
                           TRUE ~ "no epistasis"))

# View(dt %>% mutate(across(everything(), ~ . - first(.))))

epi_dt_2_sig_kd_plot <- epi_dt_2_sig_kd %>%
  ggplot(aes(x = log10(pred_kd), y = log10(kd), color = sign)) +
  geom_point(alpha = 0.4) +
  geom_abline(slope = 1, intercept = 0, linewidth = 0.3) +
  geom_hline(yintercept = log10(dt[1,]$kd), lty = 2, linewidth = 0.3) +
  geom_vline(xintercept = log10(dt[1,]$kd), lty = 2, linewidth = 0.3) +
  scale_color_manual(values = c("grey")) +
  labs(x = "Log10(Predicted Kd)", "Log10(Observed Kd)") +
  theme_classic() +
  theme(axis.line = element_line(size = 0.3, color = "black"), axis.ticks = element_line(size = 0.2, color = "black"), text = element_text(size = 9), axis.text = element_text(size = 8, color = "black"))

epi_dt_2_sig_kd_plot

##ggsave("kd_muts.tiff", plot = epi_dt_2_sig_kd_plot, width = 180/2, height = 247/4, dpi = 600, units = "mm")
```

## Positive-negative spread

What is the spread of positive and negative mutations for *k*~cat~ / *K*~M~

```{r}
epi_dt %>%
  mutate(epi = log10(catef/pred_catef)) %>%
  filter(epi >= log10(1.5) | epi <= log10(1/1.5)) %>%
  mutate(posneg = case_when(epi > 0 ~ "positive",
                           epi < 0  ~ "negative",
                           TRUE ~ "neutral")) %>%
  count(posneg) %>%
  mutate(freq = n / sum(n) * 100)
```

Then *K*~M~

```{r}
epi_dt %>%
  mutate(epi = log10(km/pred_km)) %>%
  filter(epi >= log10(1.5) | epi <= log10(1/1.5)) %>%
  mutate(posneg = case_when(epi > 0 ~ "positive",
                           epi < 0  ~ "negative",
                           TRUE ~ "neutral")) %>%
  count(posneg) %>%
  mutate(freq = n / sum(n) * 100)
```

# Calculation of epistasis in Km

## Epistasis for wt rate constants

First we create the function to calculate epistasis with the wt terms and create a parameter grid for the fold-changes in the relevant rate constants.

```{r}
epistasis_in_km_rates_vectorized <- function(a1, a2, b1, b2, koff = 62.10776, kcat = 11.4755) {
  
  epi_km <- log10( (a1*a2*koff + b1*b2*kcat) / ( (a1*koff + b1*kcat)*(a2*koff + b2*kcat) / (koff + kcat)) )
  
  return(tibble(
    a1 = a1,
    a2 = a2,
    b1 = b1,
    b2 = b2,
    del_a1_b1 = log10(a1 / b1),
    del_a2_b2 = log10(a2 / b2),
    epi_km = epi_km
  ))
}

# Generate parameter grid efficiently
param_grid <- expand_grid(
  a1 = 10^seq(-2, 2, by = 0.1),
  a2 = 10^seq(-2, 2, by = 0.1),
  b1 = 10^seq(-2, 2, by = 0.1),
  b2 = 10^seq(-2, 2, by = 0.1),
)

```

Then we perform the simulation and aggregate results together, merging duplicate measurements as an average

```{r}
# Calculate epistasis for all combinations at once
epistasis_results <- epistasis_in_km_rates_vectorized(param_grid$a1, param_grid$a2, param_grid$b1, param_grid$b2)

results <- param_grid %>%
  bind_cols(epistasis_results %>% select(del_a1_b1, del_a2_b2, epi_km))

# Aggregate data to remove duplicates for plotting by taking epi_km mean and most drastic epistasis change
results_aggregated <- results %>%
  group_by(del_a1_b1, del_a2_b2) %>%
  summarise(
    epi_km = mean(epi_km, na.rm = TRUE),
    .groups = "drop"
  )
```

And we can visualize the variation in epistasis

```{r}
# Create heatmap with epistasis
heatmap_plot <- results_aggregated %>%
  ggplot(aes(x = del_a1_b1, y = del_a2_b2)) +
  geom_tile(aes(fill = epi_km)) +
  scale_fill_gradient2(
    name = "log10 Epistasis in Km",
    low = "red",
    mid = "white", 
    high = "blue",
    midpoint = 0
  ) +
  labs(
    x = "log10 (a1 / b1)",
    y = "log10 (a2 / b2)",
  ) +
  theme_classic() +
  theme(axis.line = element_line(size = 0.3, color = "black"), 
        axis.ticks = element_line(size = 0.2, color = "black"), 
        text = element_text(size = 9), 
        axis.text = element_text(size = 8, color = "black"), 
        legend.position = "top")

# Display the plot
heatmap_plot
```

## Plotting simulated data on the epistasis heatmap

```{r}
epi_dt_inspection <- tibble(
    a1 = epi_dt_2_sig_km$mut1_koff/dt$koff[1],
    a2 = epi_dt_2_sig_km$mut2_koff/dt$koff[1],
    b1 = epi_dt_2_sig_km$mut1_kchem/dt$kchem[1],
    b2 = epi_dt_2_sig_km$mut2_kchem/dt$kchem[1],
    epi_km = log10(epi_dt_2_sig_km$km/epi_dt_2_sig_km$pred_km),
    sign = epi_dt_2_sig_km$sign
  )

epi_dt_inspection <- epi_dt_inspection %>%
  mutate(del_a1_b1 = log10(a1 / b1),
         del_a2_b2 = log10(a2 / b2)) %>%
  select(-c(a1, a2, b1, b2)) %>%
  mutate(sign = factor(sign, levels = c("no epistasis", "magnitude", "sign", "reciprocal")))

# Create heatmap with epistasis
heatmap_plot_2 <- results_aggregated %>%
  ggplot(aes(x = del_a1_b1, y = del_a2_b2)) +
  geom_tile(aes(fill = epi_km)) +
  geom_point(data = epi_dt_inspection, aes(x = del_a1_b1, y = del_a2_b2, color = sign),
             size = 0.05, alpha = 0.4) +
  scale_fill_gradient2(
    name = "log10 Epistasis in Km",
    low = "red",
    mid = "white", 
    high = "blue",
    midpoint = 0
  ) +
  scale_color_manual(values = c("grey","#fdae61","#1f78b4","#d73027")) +
  labs(
    x = "log10 (a1 / b1)",
    y = "log10 (a2 / b2)",
  ) +
  theme_classic() +
  theme(axis.line = element_line(size = 0.3, color = "black"), 
        axis.ticks = element_line(size = 0.2, color = "black"), 
        text = element_text(size = 9), 
        axis.text = element_text(size = 8, color = "black"), 
        legend.position = "top")

# Display the plot
heatmap_plot_2
```

## Varying *k*~-1~ relative to *k*~2~

```{r}
epistasis_in_km_rates_vectorized_varied <- function(a1, a2, b1, b2, koff, kcat) {
  
  epi_km <- log10( (a1*a2*koff + b1*b2*kcat) / ( (a1*koff + b1*kcat)*(a2*koff + b2*kcat) / (koff + kcat)) )
  
  return(tibble(
    a1 = a1,
    a2 = a2,
    b1 = b1,
    b2 = b2,
    del_a1_b1 = log10(a1 / b1),
    del_a2_b2 = log10(a2 / b2),
    epi_km = epi_km
  ))
}

# Calculate epistasis for all combinations at once
epistasis_results_1 <- epistasis_in_km_rates_vectorized_varied(param_grid$a1, param_grid$a2, param_grid$b1, param_grid$b2, 0.01*11.4755, 11.4755)
epistasis_results_2 <- epistasis_in_km_rates_vectorized_varied(param_grid$a1, param_grid$a2, param_grid$b1, param_grid$b2, 0.1*11.4755, 11.4755)
epistasis_results_3 <- epistasis_in_km_rates_vectorized_varied(param_grid$a1, param_grid$a2, param_grid$b1, param_grid$b2, 11.4755, 11.4755)
epistasis_results_4 <- epistasis_in_km_rates_vectorized_varied(param_grid$a1, param_grid$a2, param_grid$b1, param_grid$b2, 10*11.4755, 11.4755)
epistasis_results_5 <- epistasis_in_km_rates_vectorized_varied(param_grid$a1, param_grid$a2, param_grid$b1, param_grid$b2, 100*11.4755, 11.4755)

results_1 <- param_grid %>%
  bind_cols(epistasis_results_1 %>% select(del_a1_b1, del_a2_b2, epi_km)) %>%
  group_by(del_a1_b1, del_a2_b2) %>%
  summarise(
    epi_km = mean(epi_km, na.rm = TRUE),
    .groups = "drop"
  )

results_2 <- param_grid %>%
  bind_cols(epistasis_results_2 %>% select(del_a1_b1, del_a2_b2, epi_km)) %>%
  group_by(del_a1_b1, del_a2_b2) %>%
  summarise(
    epi_km = mean(epi_km, na.rm = TRUE),
    .groups = "drop"
  )

results_3 <- param_grid %>%
  bind_cols(epistasis_results_3 %>% select(del_a1_b1, del_a2_b2, epi_km)) %>%
  group_by(del_a1_b1, del_a2_b2) %>%
  summarise(
    epi_km = mean(epi_km, na.rm = TRUE),
    .groups = "drop"
  )

results_4 <- param_grid %>%
  bind_cols(epistasis_results_4 %>% select(del_a1_b1, del_a2_b2, epi_km)) %>%
  group_by(del_a1_b1, del_a2_b2) %>%
  summarise(
    epi_km = mean(epi_km, na.rm = TRUE),
    .groups = "drop"
  )

results_5 <- param_grid %>%
  bind_cols(epistasis_results_5 %>% select(del_a1_b1, del_a2_b2, epi_km)) %>%
  group_by(del_a1_b1, del_a2_b2) %>%
  summarise(
    epi_km = mean(epi_km, na.rm = TRUE),
    .groups = "drop"
  )
```

### *k*~-1~ = 0.01(*k*~2~)

```{r}
# Create heatmap with epistasis
heatmap_plot_0.01 <- results_1 %>%
  ggplot(aes(x = del_a1_b1, y = del_a2_b2)) +
  geom_tile(aes(fill = epi_km)) +
  scale_fill_gradient2(
    name = "log10 Epistasis in Km",
    low = "red",
    mid = "white", 
    high = "blue",
    midpoint = 0
  ) +
  labs(
    x = "log10 (a1 / b1)",
    y = "log10 (a2 / b2)",
  ) +
  theme_classic() +
  theme(axis.line = element_line(size = 0.3, color = "black"), 
        axis.ticks = element_line(size = 0.2, color = "black"), 
        text = element_text(size = 9), 
        axis.text = element_text(size = 8, color = "black"), 
        legend.position = "top")

# Display the plot
heatmap_plot_0.01
```

### *k*~-1~ = 0.1(*k*~2~)

```{r}
# Create heatmap with epistasis
heatmap_plot_0.1 <- results_2 %>%
  ggplot(aes(x = del_a1_b1, y = del_a2_b2)) +
  geom_tile(aes(fill = epi_km)) +
  scale_fill_gradient2(
    name = "log10 Epistasis in Km",
    low = "red",
    mid = "white", 
    high = "blue",
    midpoint = 0
  ) +
  labs(
    x = "log10 (a1 / b1)",
    y = "log10 (a2 / b2)",
  ) +
  theme_classic() +
  theme(axis.line = element_line(size = 0.3, color = "black"), 
        axis.ticks = element_line(size = 0.2, color = "black"), 
        text = element_text(size = 9), 
        axis.text = element_text(size = 8, color = "black"), 
        legend.position = "top")

# Display the plot
heatmap_plot_0.1
```

### *k*~-1~ = *k*~2~

```{r}
# Create heatmap with epistasis
heatmap_plot_equal <- results_3 %>%
  ggplot(aes(x = del_a1_b1, y = del_a2_b2)) +
  geom_tile(aes(fill = epi_km)) +
  scale_fill_gradient2(
    name = "log10 Epistasis in Km",
    low = "red",
    mid = "white", 
    high = "blue",
    midpoint = 0
  ) +
  labs(
    x = "log10 (a1 / b1)",
    y = "log10 (a2 / b2)",
  ) +
  theme_classic() +
  theme(axis.line = element_line(size = 0.3, color = "black"), 
        axis.ticks = element_line(size = 0.2, color = "black"), 
        text = element_text(size = 9), 
        axis.text = element_text(size = 8, color = "black"), 
        legend.position = "top")

# Display the plot
heatmap_plot_equal
```

### *k*~-1~ = 10(*k*~2~)

```{r}
# Create heatmap with epistasis
heatmap_plot_10 <- results_4 %>%
  ggplot(aes(x = del_a1_b1, y = del_a2_b2)) +
  geom_tile(aes(fill = epi_km)) +
  scale_fill_gradient2(
    name = "log10 Epistasis in Km",
    low = "red",
    mid = "white", 
    high = "blue",
    midpoint = 0
  ) +
  labs(
    x = "log10 (a1 / b1)",
    y = "log10 (a2 / b2)",
  ) +
  theme_classic() +
  theme(axis.line = element_line(size = 0.3, color = "black"), 
        axis.ticks = element_line(size = 0.2, color = "black"), 
        text = element_text(size = 9), 
        axis.text = element_text(size = 8, color = "black"), 
        legend.position = "top")

# Display the plot
heatmap_plot_10
```

### *k*~-1~ = 100(*k*~2~)

```{r}
# Create heatmap with epistasis
heatmap_plot_100 <- results_5 %>%
  ggplot(aes(x = del_a1_b1, y = del_a2_b2)) +
  geom_tile(aes(fill = epi_km)) +
  scale_fill_gradient2(
    name = "log10 Epistasis in Km",
    low = "red",
    mid = "white", 
    high = "blue",
    midpoint = 0
  ) +
  labs(
    x = "log10 (a1 / b1)",
    y = "log10 (a2 / b2)",
  ) +
  theme_classic() +
  theme(axis.line = element_line(size = 0.3, color = "black"), 
        axis.ticks = element_line(size = 0.2, color = "black"), 
        text = element_text(size = 9), 
        axis.text = element_text(size = 8, color = "black"), 
        legend.position = "top")

# Display the plot
heatmap_plot_100
```
